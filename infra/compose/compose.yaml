services:
  api:
    build:
      context: ../../server
      dockerfile: Dockerfile
    environment:
      PORT: "${API_PORT:-3000}"
      NODE_ENV: "${NODE_ENV:-production}"
      DATABASE_URL: "${DATABASE_URL}"
      REDIS_URL: "${REDIS_URL}"
      AI_SERVICE_URL: "${AI_SERVICE_URL}"
      QDRANT_URL: "${QDRANT_URL}"
      NEO4J_URI: "${NEO4J_URI}"
      NEO4J_USER: "${NEO4J_USER}"
      NEO4J_PASSWORD: "${NEO4J_PASSWORD}"
      JWT_SECRET: "${JWT_SECRET}"
      STORAGE_PROVIDER: "${STORAGE_PROVIDER}"
      S3_ENDPOINT: "${S3_ENDPOINT}"
      S3_ACCESS_KEY: "${S3_ACCESS_KEY}"
      S3_SECRET_KEY: "${S3_SECRET_KEY}"
      S3_BUCKET: "${S3_BUCKET}"
      S3_REGION: "${S3_REGION}"
      SENTRY_DSN: "${SENTRY_DSN}"
    ports:
      - "${API_PORT:-3000}:3000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
      qdrant:
        condition: service_healthy
      neo4j:
        condition: service_healthy
      object-storage:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "node", "-e", "require('http').get('http://localhost:3000/health', res => process.exit(res.statusCode === 200 ? 0 : 1)).on('error', () => process.exit(1));"]
      interval: 10s
      timeout: 5s
      retries: 10
    networks:
      - backend
    restart: unless-stopped

  ai:
    build:
      context: ../../ai
      dockerfile: Dockerfile
    environment:
      PORT: "${AI_PORT:-8080}"
      REDIS_URL: "${REDIS_URL}"
      AI_WORKER_QUEUE: "${AI_WORKER_QUEUE}"
      EMBEDDINGS_DIM: "${EMBEDDINGS_DIM}"
      QDRANT_URL: "${QDRANT_URL}"
      NEO4J_URI: "${NEO4J_URI}"
      NEO4J_USER: "${NEO4J_USER}"
      NEO4J_PASSWORD: "${NEO4J_PASSWORD}"
      STORAGE_PROVIDER: "${STORAGE_PROVIDER}"
      S3_ENDPOINT: "${S3_ENDPOINT}"
      S3_ACCESS_KEY: "${S3_ACCESS_KEY}"
      S3_SECRET_KEY: "${S3_SECRET_KEY}"
      S3_BUCKET: "${S3_BUCKET}"
      S3_REGION: "${S3_REGION}"
      SENTRY_DSN: "${SENTRY_DSN}"
    ports:
      - "${AI_PORT:-8080}:8080"
    depends_on:
      redis:
        condition: service_healthy
      qdrant:
        condition: service_healthy
      neo4j:
        condition: service_healthy
      object-storage:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request,sys;sys.exit(0 if urllib.request.urlopen('http://localhost:8080/health').status==200 else 1)"]
      interval: 10s
      timeout: 5s
      retries: 10
    networks:
      - backend
    restart: unless-stopped

  worker:
    build:
      context: ../../worker
      dockerfile: Dockerfile
    environment:
      PORT: "${WORKER_PORT:-8081}"
      REDIS_URL: "${REDIS_URL}"
      AI_WORKER_QUEUE: "${AI_WORKER_QUEUE}"
      LOG_LEVEL: "${LOG_LEVEL}"
      QDRANT_URL: "${QDRANT_URL}"
      NEO4J_URI: "${NEO4J_URI}"
      NEO4J_USER: "${NEO4J_USER}"
      NEO4J_PASSWORD: "${NEO4J_PASSWORD}"
      STORAGE_PROVIDER: "${STORAGE_PROVIDER}"
      S3_ENDPOINT: "${S3_ENDPOINT}"
      S3_ACCESS_KEY: "${S3_ACCESS_KEY}"
      S3_SECRET_KEY: "${S3_SECRET_KEY}"
      S3_BUCKET: "${S3_BUCKET}"
      S3_REGION: "${S3_REGION}"
      SENTRY_DSN: "${SENTRY_DSN}"
    ports:
      - "${WORKER_PORT:-8081}:8081"
    depends_on:
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request,sys;sys.exit(0 if urllib.request.urlopen('http://localhost:8081/health').status==200 else 1)"]
      interval: 10s
      timeout: 5s
      retries: 10
    networks:
      - backend
    restart: unless-stopped

  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: "${POSTGRES_USER}"
      POSTGRES_PASSWORD: "${POSTGRES_PASSWORD}"
      POSTGRES_DB: "${POSTGRES_DB}"
    ports:
      - "${POSTGRES_PORT:-5432}:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 10s
      timeout: 5s
      retries: 10
    networks:
      - backend
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "${REDIS_PORT:-6379}:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 3s
      retries: 10
    networks:
      - backend
    restart: unless-stopped

  qdrant:
    image: qdrant/qdrant:latest
    ports:
      - "${QDRANT_PORT:-6333}:6333"
    volumes:
      - qdrant-data:/qdrant/storage
    healthcheck:
      test: ["CMD-SHELL", "apt-get update -y >/dev/null 2>&1 && apt-get install -y curl >/dev/null 2>&1 && curl -fsS http://localhost:6333/healthz >/dev/null 2>&1"]
      interval: 10s
      timeout: 5s
      retries: 10
    networks:
      - backend
    restart: unless-stopped

  neo4j:
    image: neo4j:5.23
    environment:
      NEO4J_AUTH: "${NEO4J_USER}/${NEO4J_PASSWORD}"
    ports:
      - "${NEO4J_HTTP_PORT:-7474}:7474"
      - "${NEO4J_BOLT_PORT:-7687}:7687"
    volumes:
      - neo4j-data:/data
      - neo4j-logs:/logs
    healthcheck:
      test: ["CMD-SHELL", "cypher-shell -u ${NEO4J_USER} -p ${NEO4J_PASSWORD} 'RETURN 1' >/dev/null 2>&1 || exit 1"]
      interval: 10s
      timeout: 10s
      retries: 10
    networks:
      - backend
    restart: unless-stopped

  object-storage:
    image: minio/minio:latest
    command: server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: "${S3_ACCESS_KEY}"
      MINIO_ROOT_PASSWORD: "${S3_SECRET_KEY}"
    ports:
      - "${MINIO_PORT:-9000}:9000"
      - "${MINIO_CONSOLE_PORT:-9001}:9001"
    volumes:
      - minio-data:/data
    healthcheck:
      test: ["CMD-SHELL", "curl -fsS http://localhost:9000/minio/health/ready >/dev/null 2>&1"]
      interval: 10s
      timeout: 5s
      retries: 10
    networks:
      - backend
    restart: unless-stopped

volumes:
  postgres-data:
  qdrant-data:
  neo4j-data:
  neo4j-logs:
  minio-data:

networks:
  backend:
    driver: bridge
